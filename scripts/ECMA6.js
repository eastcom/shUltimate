/** * ECMA6新语法及常用小函数 * @authors Kerry W (wangxuan@eastcom-sw.com) * @date    2016-09-06 14:43:34 * @version $Id$ *///动态修改函数Function.prototype.before = function(beforefn){    var _self = this;//原函数的引用    return function(){        beforefn.apply(this,arguments);//执行新函数        return _self.apply(this,arguments);//执行原函数    };};Function.prototype.after = function(afterfn){    var _self = this;    return function(){        var ret = _self.apply(this,arguments);//执行原函数        afterfn.apply(this,arguments);        return ret;    };};//新增Array方法if (!Array.isArray) {  Array.isArray = function(arg) {    return Object.prototype.toString.call(arg) === '[object Array]';  };}if (!Array.from) {  Array.from = (function () {    var toStr = Object.prototype.toString;    var isCallable = function (fn) {      return typeof fn === 'function' || toStr.call(fn) === '[object Function]';    };    var toInteger = function (value) {      var number = Number(value);      if (isNaN(number)) { return 0; }      if (number === 0 || !isFinite(number)) { return number; }      return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));    };    var maxSafeInteger = Math.pow(2, 53) - 1;    var toLength = function (value) {      var len = toInteger(value);      return Math.min(Math.max(len, 0), maxSafeInteger);    };    // The length property of the from method is 1.    return function from(arrayLike/*, mapFn, thisArg */) {      // 1. Let C be the this value.      var C = this;      // 2. Let items be ToObject(arrayLike).      var items = Object(arrayLike);      // 3. ReturnIfAbrupt(items).      if (arrayLike == null) {        throw new TypeError("Array.from requires an array-like object - not null or undefined");      }      // 4. If mapfn is undefined, then let mapping be false.      var mapFn = arguments.length > 1 ? arguments[1] : void undefined;      var T;      if (typeof mapFn !== 'undefined') {        // 5. else              // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.        if (!isCallable(mapFn)) {          throw new TypeError('Array.from: when provided, the second argument must be a function');        }        // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.        if (arguments.length > 2) {          T = arguments[2];        }      }      // 10. Let lenValue be Get(items, "length").      // 11. Let len be ToLength(lenValue).      var len = toLength(items.length);      // 13. If IsConstructor(C) is true, then      // 13. a. Let A be the result of calling the [[Construct]] internal method of C with an argument list containing the single item len.      // 14. a. Else, Let A be ArrayCreate(len).      var A = isCallable(C) ? Object(new C(len)) : new Array(len);      // 16. Let k be 0.      var k = 0;      // 17. Repeat, while k < len… (also steps a - h)      var kValue;      while (k < len) {        kValue = items[k];        if (mapFn) {          A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);        } else {          A[k] = kValue;        }        k += 1;      }      // 18. Let putStatus be Put(A, "length", len, true).      A.length = len;      // 20. Return A.      return A;    };  }());}if (!Array.prototype.some){    Array.prototype.some = function(fun){      'use strict';      if (this === void 0 || this === null) throw new TypeError();      var t = Object(this);      var len = t.length >>> 0;      if (typeof fun !== 'function') throw new TypeError();      var thisArg = arguments.length >= 2 ? arguments[1] : void 0;      for (var i = 0; i < len; i++)      {        if (i in t && fun.call(thisArg, t[i], i, t)) return true;      }      return false;    };              }if (!Array.prototype.every){  Array.prototype.every = function(fun)  {    'use strict';    if (this === void 0 || this === null)      throw new TypeError();    var t = Object(this);    var len = t.length >>> 0;    if (typeof fun !== 'function')        throw new TypeError();    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;    for (var i = 0; i < len; i++)    {      if (i in t && !fun.call(thisArg, t[i], i, t))        return false;    }    return true;  };}if (!Array.prototype.fill) {  Array.prototype.fill = function(value) {    // Steps 1-2.    if (this == null) {      throw new TypeError('this is null or not defined');    }    var O = Object(this);    // Steps 3-5.    var len = O.length >>> 0; // parseInt(O.length)    // Steps 6-7.    var start = arguments[1];    var relativeStart = start >> 0;    // Step 8.    var k = relativeStart < 0 ?      Math.max(len + relativeStart, 0) :      Math.min(relativeStart, len);    // Steps 9-10.    var end = arguments[2];    var relativeEnd = end === undefined ?      len :       end >> 0;    // Step 11.    var final = relativeEnd < 0 ?      Math.max(len + relativeEnd, 0) :      Math.min(relativeEnd, len);    // Step 12.    while(k < final) {        O[k] = value;        k++;    }    // Step 13.    return O;  };}if (!Array.prototype.includes) {  Array.prototype.includes = function(searchElement /*, fromIndex*/ ) {    'use strict';    var O = Object(this);    var len = parseInt(O.length) || 0;    if (len === 0) {      return false;    }    var n = parseInt(arguments[1]) || 0;    var k;    if (n >= 0) {      k = n;    } else {      k = len + n;      if (k < 0) {k = 0;}    }    var currentElement;    while (k < len) {      currentElement = O[k];      if (searchElement === currentElement ||         (searchElement !== searchElement && currentElement !== currentElement)) {        return true;      }      k++;    }    return false;  };}if (!Array.prototype.find) {  Object.defineProperty(Array.prototype, 'find', {    enumerable: false,    configurable: true,    writable: true,    value: function(predicate) {      if (this == null) {        throw new TypeError('Array.prototype.find called on null or undefined');      }      if (typeof predicate !== 'function') {        throw new TypeError('predicate must be a function');      }      var list = Object(this);      var length = list.length >>> 0;      var thisArg = arguments[1];      var value;      for (var i = 0; i < length; i++) {        if (i in list) {          value = list[i];          if (predicate.call(thisArg, value, i, list)) {            return value;          }        }      }      return undefined;    }  });}if (!Array.prototype.findIndex) {  Array.prototype.findIndex = function(predicate) {    if (this === null) {      throw new TypeError('Array.prototype.findIndex called on null or undefined');    }    if (typeof predicate !== 'function') {      throw new TypeError('predicate must be a function');    }    var list = Object(this);    var length = list.length >>> 0;    var thisArg = arguments[1];    var value;    for (var i = 0; i < length; i++) {      value = list[i];      if (predicate.call(thisArg, value, i, list)) {        return i;      }    }    return -1;  };}//新增String方法if (!String.prototype.includes) {  String.prototype.includes = function(search, start) {    'use strict';    if (typeof start !== 'number') {      start = 0;    }        if (start + search.length > this.length) {      return false;    } else {      return this.indexOf(search, start) !== -1;    }  };}if (!String.prototype.endsWith) {  (function() {    'use strict'; // needed to support `apply`/`call` with `undefined`/`null`    var defineProperty = (function() {      // IE 8 only supports `Object.defineProperty` on DOM elements      try {        var object = {};        var $defineProperty = Object.defineProperty;        var result = $defineProperty(object, object, object) && $defineProperty;      } catch(error) {}      return result;    }());    var toString = {}.toString;    var endsWith = function(search) {      if (this == null) {        throw TypeError();      }      var string = String(this);      if (search && toString.call(search) == '[object RegExp]') {        throw TypeError();      }      var stringLength = string.length;      var searchString = String(search);      var searchLength = searchString.length;      var pos = stringLength;      if (arguments.length > 1) {        var position = arguments[1];        if (position !== undefined) {          // `ToInteger`          pos = position ? Number(position) : 0;          if (pos != pos) { // better `isNaN`            pos = 0;          }        }      }      var end = Math.min(Math.max(pos, 0), stringLength);      var start = end - searchLength;      if (start < 0) {        return false;      }      var index = -1;      while (++index < searchLength) {        if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {          return false;        }      }      return true;    };    if (defineProperty) {      defineProperty(String.prototype, 'endsWith', {        'value': endsWith,        'configurable': true,        'writable': true      });    } else {      String.prototype.endsWith = endsWith;    }  }());}//自定义模板引擎function templateEngine(html, options) {  var re = /<%([^%>]+)?%>/g, reExp = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g, code = 'var r=[];\n', cursor = 0;  var add = function(line, js) {      js? (code += line.match(reExp) ? line + '\n' : 'r.push(' + line + ');\n') :          (code += line != '' ? 'r.push("' + line.replace(/"/g, '\\"') + '");\n' : '');      return add;  }  while(match = re.exec(html)) {      add(html.slice(cursor, match.index))(match[1], true);      cursor = match.index + match[0].length;  }  add(html.substr(cursor, html.length - cursor));  code += 'return r.join("");';  return new Function(code.replace(/[\r\t\n]/g, '')).apply(options);}//计算对象属性个数Object.prototype.count = (Object.prototype.hasOwnProperty('__count__'))    ? function(){        return this.__count__;    }     : function(){        var count = 0;        for (var i in this) {          if (this.hasOwnProperty(i)){            count++;          }         }        return count;                                    };//求线段交点function segmentsIntr(a, b, c, d){      // 三角形abc 面积的2倍      var area_abc = (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);          // 三角形abd 面积的2倍      var area_abd = (a.x - d.x) * (b.y - d.y) - (a.y - d.y) * (b.x - d.x);         // 面积符号相同则两点在线段同侧,不相交 (对点在线段上的情况,本例当作不相交处理);      if ( area_abc*area_abd>=0 ) {          return false;      }        // 三角形cda 面积的2倍      var area_cda = (c.x - a.x) * (d.y - a.y) - (c.y - a.y) * (d.x - a.x);      // 三角形cdb 面积的2倍      // 注意: 这里有一个小优化.不需要再用公式计算面积,而是通过已知的三个面积加减得出.      var area_cdb = area_cda + area_abc - area_abd ;      if (  area_cda * area_cdb >= 0 ) {          return false;      }        //计算交点坐标      var t = area_cda / ( area_abd- area_abc );      var dx= t*(b.x - a.x),          dy= t*(b.y - a.y);      return { x: a.x + dx , y: a.y + dy };  } 